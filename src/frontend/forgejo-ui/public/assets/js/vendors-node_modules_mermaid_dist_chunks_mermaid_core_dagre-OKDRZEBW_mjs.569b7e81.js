"use strict";(self.webpackChunkforgejo=self.webpackChunkforgejo||[]).push([["vendors-node_modules_mermaid_dist_chunks_mermaid_core_dagre-OKDRZEBW_mjs"],{"./node_modules/lodash-es/clone.js":function(Y,b,u){var E=u("./node_modules/lodash-es/_baseClone.js"),P=4;function R(O){return(0,E.A)(O,P)}b.A=R},"./node_modules/mermaid/dist/chunks/mermaid.core/dagre-OKDRZEBW.mjs":function(Y,b,u){u.r(b),u.d(b,{render:function(){return ee}});var E=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-IIMUDSI4.mjs"),P=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-VV3M67IP.mjs"),R=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-HRU6DDCH.mjs"),O=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-K557N5IZ.mjs"),ne=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-H2D2JQ3I.mjs"),te=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-C3MQ5ANM.mjs"),se=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-O4NI6UNU.mjs"),s=u("./node_modules/mermaid/dist/chunks/mermaid.core/chunk-YTJNT7DU.mjs"),F=u("./node_modules/dagre-d3-es/src/dagre/index.js"),p=u("./node_modules/lodash-es/isUndefined.js"),V=u("./node_modules/lodash-es/clone.js"),K=u("./node_modules/lodash-es/map.js"),re=u("./node_modules/dagre-d3-es/src/graphlib/graph.js");function w(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:Z(e),edges:Q(e)};return p.A(e.graph())||(t.value=V.A(e.graph())),t}function Z(e){return K.A(e.nodes(),function(t){var n=e.node(t),d=e.parent(t),i={v:t};return p.A(n)||(i.value=n),p.A(d)||(i.parent=d),i})}function Q(e){return K.A(e.edges(),function(t){var n=e.edge(t),d={v:t.v,w:t.w};return p.A(t.name)||(d.name=t.name),p.A(n)||(d.value=n),d})}function ie(e){var t=new Graph(e.options).setGraph(e.value);return _.each(e.nodes,function(n){t.setNode(n.v,n.value),n.parent&&t.setParent(n.v,n.parent)}),_.each(e.edges,function(n){t.setEdge({v:n.v,w:n.w,name:n.name},n.value)}),t}var U=u("./node_modules/dagre-d3-es/src/graphlib/index.js"),c=new Map,X=new Map,T=new Map,W=(0,s.K2)(()=>{X.clear(),T.clear(),c.clear()},"clear"),k=(0,s.K2)((e,t)=>{const n=X.get(t)||[];return s.Rm.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),z=(0,s.K2)((e,t)=>{const n=X.get(t)||[];return s.Rm.info("Descendants of ",t," is ",n),s.Rm.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||k(e.v,t)||k(e.w,t)||n.includes(e.w):(s.Rm.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),B=(0,s.K2)((e,t,n,d)=>{s.Rm.warn("Copying children of ",e,"root",d,"data",t.node(e),d);const i=t.children(e)||[];e!==d&&i.push(e),s.Rm.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach(o=>{if(t.children(o).length>0)B(o,t,n,d);else{const l=t.node(o);s.Rm.info("cp ",o," to ",d," with parent ",e),n.setNode(o,l),d!==t.parent(o)&&(s.Rm.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==d&&o!==e?(s.Rm.debug("Setting parent",o,e),n.setParent(o,e)):(s.Rm.info("In copy ",e,"root",d,"data",t.node(e),d),s.Rm.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==d,"node!==clusterId",o!==e));const f=t.edges(o);s.Rm.debug("Copying Edges",f),f.forEach(a=>{s.Rm.info("Edge",a);const h=t.edge(a.v,a.w,a.name);s.Rm.info("Edge data",h,d);try{z(a,d)?(s.Rm.info("Copying as ",a.v,a.w,h,a.name),n.setEdge(a.v,a.w,h,a.name),s.Rm.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.Rm.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",d," clusterId:",e)}catch(v){s.Rm.error(v)}})}s.Rm.debug("Removing node",o),t.removeNode(o)})},"copy"),J=(0,s.K2)((e,t)=>{const n=t.children(e);let d=[...n];for(const i of n)T.set(i,e),d=[...d,...J(i,t)];return d},"extractDescendants"),$=(0,s.K2)((e,t,n)=>{const d=e.edges().filter(a=>a.v===t||a.w===t),i=e.edges().filter(a=>a.v===n||a.w===n),o=d.map(a=>({v:a.v===t?n:a.v,w:a.w===t?t:a.w})),l=i.map(a=>({v:a.v,w:a.w}));return o.filter(a=>l.some(h=>a.v===h.v&&a.w===h.w))},"findCommonEdges"),S=(0,s.K2)((e,t,n)=>{const d=t.children(e);if(s.Rm.trace("Searching children of id ",e,d),d.length<1)return e;let i;for(const o of d){const l=S(o,t,n),f=$(t,n,l);if(l)if(f.length>0)i=l;else return l}return i},"findNonClusterChild"),M=(0,s.K2)(e=>!c.has(e)||!c.get(e).externalConnections?e:c.has(e)?c.get(e).id:e,"getAnchorId"),L=(0,s.K2)((e,t)=>{if(!e||t>10){s.Rm.debug("Opting out, no graph ");return}else s.Rm.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.Rm.warn("Cluster identified",n," Replacement id in edges: ",S(n,e,n)),X.set(n,J(n,e)),c.set(n,{id:S(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const d=e.children(n),i=e.edges();d.length>0?(s.Rm.debug("Cluster identified",n,X),i.forEach(o=>{const l=k(o.v,n),f=k(o.w,n);l^f&&(s.Rm.warn("Edge: ",o," leaves cluster ",n),s.Rm.warn("Descendants of XXX ",n,": ",X.get(n)),c.get(n).externalConnections=!0)})):s.Rm.debug("Not a cluster ",n,X)});for(let n of c.keys()){const d=c.get(n).id,i=e.parent(d);i!==n&&c.has(i)&&!c.get(i).externalConnections&&(c.get(n).id=i)}e.edges().forEach(function(n){const d=e.edge(n);s.Rm.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.Rm.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let i=n.v,o=n.w;if(s.Rm.warn("Fix XXX",c,"ids:",n.v,n.w,"Translating: ",c.get(n.v)," --- ",c.get(n.w)),c.get(n.v)||c.get(n.w)){if(s.Rm.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),i=M(n.v),o=M(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){const l=e.parent(i);c.get(l).externalConnections=!0,d.fromCluster=n.v}if(o!==n.w){const l=e.parent(o);c.get(l).externalConnections=!0,d.toCluster=n.w}s.Rm.warn("Fix Replacing with XXX",i,o,n.name),e.setEdge(i,o,d,n.name)}}),s.Rm.warn("Adjusted Graph",w(e)),G(e,0),s.Rm.trace(c)},"adjustClustersAndEdges"),G=(0,s.K2)((e,t)=>{if(s.Rm.warn("extractor - ",t,w(e),e.children("D")),t>10){s.Rm.error("Bailing out");return}let n=e.nodes(),d=!1;for(const i of n){const o=e.children(i);d=d||o.length>0}if(!d){s.Rm.debug("Done, no node has children",e.nodes());return}s.Rm.debug("Nodes = ",n,t);for(const i of n)if(s.Rm.debug("Extracting node",i,c,c.has(i)&&!c.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",t),!c.has(i))s.Rm.debug("Not a cluster",i,t);else if(!c.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){s.Rm.warn("Cluster without external connections, without a parent and with children",i,t);let l=e.graph().rankdir==="TB"?"LR":"TB";c.get(i)?.clusterData?.dir&&(l=c.get(i).clusterData.dir,s.Rm.warn("Fixing dir",c.get(i).clusterData.dir,l));const f=new U.T({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.Rm.warn("Old graph before copy",w(e)),B(i,e,f,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:c.get(i).clusterData,label:c.get(i).label,graph:f}),s.Rm.warn("New graph after copy node: (",i,")",w(f)),s.Rm.debug("Old graph after copy",w(e))}else s.Rm.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!c.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),t),s.Rm.debug(c);n=e.nodes(),s.Rm.warn("New list of nodes",n);for(const i of n){const o=e.node(i);s.Rm.warn(" Now next level",i,o),o?.clusterNode&&G(o.graph,t+1)}},"extractor"),I=(0,s.K2)((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(d=>{const i=e.children(d),o=I(e,i);n=[...n,...o]}),n},"sorter"),q=(0,s.K2)(e=>I(e,e.children()),"sortNodesByHierarchy"),H=(0,s.K2)(async(e,t,n,d,i,o)=>{s.Rm.warn("Graph in recursive render:XAX",w(t),i);const l=t.graph().rankdir;s.Rm.trace("Dir in recursive render - dir:",l);const f=e.insert("g").attr("class","root");t.nodes()?s.Rm.info("Recursive render XXX",t.nodes()):s.Rm.info("No nodes found for",t),t.edges().length>0&&s.Rm.info("Recursive edges",t.edge(t.edges()[0]));const a=f.insert("g").attr("class","clusters"),h=f.insert("g").attr("class","edgePaths"),v=f.insert("g").attr("class","edgeLabels"),N=f.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(m){const r=t.node(m);if(i!==void 0){const g=JSON.parse(JSON.stringify(i.clusterData));s.Rm.trace(`Setting data for parent cluster XXX
 Node.id = `,m,`
 data=`,g.height,`
Parent cluster`,i.height),t.setNode(i.id,g),t.parent(m)||(s.Rm.trace("Setting parent",m,i.id),t.setParent(m,i.id,g))}if(s.Rm.info("(Insert) Node XXX"+m+": "+JSON.stringify(t.node(m))),r?.clusterNode){s.Rm.info("Cluster identified XBX",m,r.width,t.node(m));const{ranksep:g,nodesep:y}=t.graph();r.graph.setGraph({...r.graph.graph(),ranksep:g+25,nodesep:y});const D=await H(N,r.graph,n,d,t.node(m),o),A=D.elem;(0,R.lC)(r,A),r.diff=D.diff||0,s.Rm.info("New compound node after recursive render XAX",m,"width",r.width,"height",r.height),(0,R.U7)(A,r)}else t.children(m).length>0?(s.Rm.trace("Cluster - the non recursive path XBX",m,r.id,r,r.width,"Graph:",t),s.Rm.trace(S(r.id,t)),c.set(r.id,{id:S(r.id,t),node:r})):(s.Rm.trace("Node - the non recursive path XAX",m,N,t.node(m),l),await(0,R.on)(N,t.node(m),{config:o,dir:l}))})),await(0,s.K2)(async()=>{const m=t.edges().map(async function(r){const g=t.edge(r.v,r.w,r.name);s.Rm.info("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),s.Rm.info("Edge "+r.v+" -> "+r.w+": ",r," ",JSON.stringify(t.edge(r))),s.Rm.info("Fix",c,"ids:",r.v,r.w,"Translating: ",c.get(r.v),c.get(r.w)),await(0,E.jP)(v,g)});await Promise.all(m)},"processEdges")(),s.Rm.info("Graph before layout:",JSON.stringify(w(t))),s.Rm.info("############################################# XXX"),s.Rm.info("###                Layout                 ### XXX"),s.Rm.info("############################################# XXX"),(0,F.Zp)(t),s.Rm.info("Graph after layout:",JSON.stringify(w(t)));let j=0,{subGraphTitleTotalMargin:x}=(0,O.O)(o);return await Promise.all(q(t).map(async function(m){const r=t.node(m);if(s.Rm.info("Position XBX => "+m+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height),r?.clusterNode)r.y+=x,s.Rm.info("A tainted cluster node XBX1",m,r.id,r.width,r.height,r.x,r.y,t.parent(m)),c.get(r.id).node=r,(0,R.U_)(r);else if(t.children(m).length>0){s.Rm.info("A pure cluster node XBX1",m,r.id,r.x,r.y,r.width,r.height,t.parent(m)),r.height+=x,t.node(r.parentId);const g=r?.padding/2||0,y=r?.labelBBox?.height||0,D=y-g||0;s.Rm.debug("OffsetY",D,"labelHeight",y,"halfPadding",g),await(0,R.U)(a,r),c.get(r.id).node=r}else{const g=t.node(r.parentId);r.y+=x/2,s.Rm.info("A regular node XBX1 - using the padding",r.id,"parent",r.parentId,r.width,r.height,r.x,r.y,"offsetY",r.offsetY,"parent",g,g?.offsetY,r),(0,R.U_)(r)}})),t.edges().forEach(function(m){const r=t.edge(m);s.Rm.info("Edge "+m.v+" -> "+m.w+": "+JSON.stringify(r),r),r.points.forEach(A=>A.y+=x/2);const g=t.node(m.v);var y=t.node(m.w);const D=(0,E.Jo)(h,r,c,n,g,y,d);(0,E.T_)(r,D)}),t.nodes().forEach(function(m){const r=t.node(m);s.Rm.info(m,r.type,r.diff),r.isGroup&&(j=r.diff)}),s.Rm.warn("Returning from recursive render XAX",f,j),{elem:f,diff:j}},"recursiveRender"),ee=(0,s.K2)(async(e,t)=>{const n=new U.T({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=t.select("g");(0,E.g0)(d,e.markers,e.type,e.diagramId),(0,R.gh)(),(0,E.IU)(),(0,R.IU)(),W(),e.nodes.forEach(o=>{n.setNode(o.id,{...o}),o.parentId&&n.setParent(o.id,o.parentId)}),s.Rm.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){const l=o.start,f=l+"---"+l+"---1",a=l+"---"+l+"---2",h=n.node(l);n.setNode(f,{domId:f,id:f,parentId:h.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(f,h.parentId),n.setNode(a,{domId:a,id:a,parentId:h.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(a,h.parentId);const v=structuredClone(o),N=structuredClone(o),C=structuredClone(o);v.label="",v.arrowTypeEnd="none",v.id=l+"-cyclic-special-1",N.arrowTypeStart="none",N.arrowTypeEnd="none",N.id=l+"-cyclic-special-mid",C.label="",h.isGroup&&(v.fromCluster=l,C.toCluster=l),C.id=l+"-cyclic-special-2",C.arrowTypeStart="none",n.setEdge(l,f,v,l+"-cyclic-special-0"),n.setEdge(f,a,N,l+"-cyclic-special-1"),n.setEdge(a,l,C,l+"-cyc<lic-special-2")}else n.setEdge(o.start,o.end,{...o},o.id)}),s.Rm.warn("Graph at first:",JSON.stringify(w(n))),L(n),s.Rm.warn("Graph after XAX:",JSON.stringify(w(n)));const i=(0,s.D7)();await H(d,n,e.type,e.diagramId,void 0,i)},"render")}}]);
